## 死锁的四个必要条件
1. 互斥条件
2. 占有且等待条件
3. 非剥夺条件
4. 循环条件
## 解决死锁
主要从四个方面
1. 预防死锁：*主要是从死锁的三个必要条件的角度来解决*
    * 资源一次性分配：破坏请求和保持条件。当某个资源只在进程结束时使用一小会，那么在进程运行期间，这个资源都被占用，资源利用率很低。比较好的方法是，进程开始时，只申请和使用进程启动的资源，在运行过程中不断申请新的资源，同时释放已经使用完的资源。
    * 可剥夺资源：当进程新申请的资源不满足时，释放已经分配的资源。破坏不可剥夺条件。在使用某些资源，比如打印机时，当强制剥夺已分配资源的时候，会导致打印机资源打印的信息不连续的问题。
    * 资源有序分配：系统给进程编号，按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。
2. 避免死锁：
    银行家算法：分配资源前先评估风险，会不会在分配后导致死锁。　即分配给一个进程资源的时候，该进程能否全部返还占用的资源。
3. 检测死锁：
    建立资源分配表和进程等待表。有向图。
4. 解除死锁：
    从其他进程强制剥夺资源给死锁进程。可以直接撤销死锁进程，或撤销代价最小的进程

---
后三个方面主要是由系统来提供，第一个方面主要靠业务逻辑的良好设计。
### 对应到MySQL，MySQL为4和3提供了系统支持
1. innodb_lock_wait_timeout，设置等待锁超时时间，超过这个时间事务（或语句，由参数innodb_rollback_on_timeout决定）将回滚。
2. innodb_deadlock_detect，设置为on，当事务加入时，检测是否会因为自己产生死锁，对应“检测死锁”。这个方法会导致数据库性能低下。回滚整个事务。
### 从业务角度，我们能从预防死锁的三个方面做出什么努力？
1. 资源一次性分配：我们应该尽量晚得获取锁（为了两阶段锁机制，也应该如此）
2. 占有且等待条件：可以判断某行上是否有锁（锁查看），如果有，就回滚。
3. 资源有序分配：获取锁的顺序一致。

